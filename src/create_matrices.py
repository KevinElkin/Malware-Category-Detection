import glob 
from collections import defaultdict
import numpy as np
from pathlib import Path
import re
import json
import os
import ast
from scipy.sparse import lil_matrix, csr_matrix,save_npz,load_npz
import random
from random import sample
from tqdm import tqdm

# random.seed(4)

def get_API_calls(smali_file,app_name,meta):
    """
    Method to get the API information present in one smali file. 

    Params - 1. smali_file - file path of the .smali file
             2. app_name - app this .smali file belongs to 
             3. meta - empty data structure to store metadata about APIs
    """
    #boolean check to see if a line being checked is within a method
    method_open = False
    method_apis = []

    #regex to search for lines starting with '.method'
    method_open_regex = re.compile('\.method.*')
    #regex to search for lines with '.end method'
    close_method_regex = re.compile('\.end method.*')
    #regex to search for lines starting with 'invoke' 
    invoke_method_regex = re.compile('^invoke.*')
    #regex to get rid of obfuscated APIs ..../a/b/a/..
    obfuscated_regex = re.compile('\/.\/.\/')
    
    #looping through all lines in smali files
    for l in open(smali_file):
        
        #if lines starting with '.method'
        method_regex = method_open_regex.findall(l)
        if len(method_regex) > 0:
            method_open = True
            method_start = method_regex[0].split(' ')[1:]
            method_header = ' '.join(method_start)
            # method_name = method_header
        
        #if line starts with '.end method'
        method_end = close_method_regex.findall(l)
        if len(method_end) > 0:
            method_open = False
            #end of current method so we add the APIs seen into a list
            if method_apis:
                meta['code_blocks'].append(method_apis)
            method_apis = []
            
        
        #if we found an API being invoked
        API_call = invoke_method_regex.findall(l.strip())

        if len(API_call) > 0:
            API_call_array = API_call[0].split(' ')
            #type of invoke method
            invoke_method_type = API_call_array[0].split('-')[-1]
            api_call = API_call_array[-1].split('->')
            #removing input params
            api_call[1] = re.sub('\(.*\)','()',api_call[1])
            try:
                #package name 
                package = api_call[0]
                
                #api name
                api_name = '->'.join(api_call)
                api_name = re.sub('->\w\(\)', '->a()', api_name)
                if obfuscated_regex.findall(api_name) or 'init' in api_name:
                    continue
                    
                method_apis.append(api_name)
                meta['invoke_method'][invoke_method_type].add(api_name)
                meta['packages'][package].add(api_name)
                meta['app_apis'][api_name] += 1

            except e:
                print(e)
    return meta

def get_app_api_calls(app_name,outpath,malware = False):
    """
    Method to get the information required to compute the 
    A,B,I,P matrices for one app in the Hindroid paper

    Params - 1. app_name - file name of app for which we get the metadata
             2. outpath - location to store meta data
             3. malware_path - path for directory containing malware apps
    """
    #initialises the meta data to be collected
    print(app_name)
    same_code_block = []
    packages = defaultdict(set)
    invoke_method = defaultdict(set)
    app_apis = defaultdict(int)
    meta = {'invoke_method':invoke_method, 'packages':packages, \
            'code_blocks':same_code_block, 'app_apis': app_apis}
    #iterates through all smali files of an app 
    if malware:
        pathlist = Path(outpath).glob('**/' + app_name + '/**/*.smali')
    else:
        pathlist = Path(outpath+'/APK').glob('**/' + app_name + '/**/*.smali')
    smalli_lis = [i for i in pathlist if '$' not in str(i)]
    for path in tqdm(smalli_lis):
        path_in_str = str(path)
        #gets metadata for each .smali file
        meta = get_API_calls(path_in_str,app_name,meta)
    return meta

def set_default(obj):
    """
    Method to dump a set as a list in JSON
    """
    if isinstance(obj, set):
        return list(obj)
    raise TypeError


def save_files(meta,p):
    """
    Saving meta data to files on disk

    Params - 1. meta - metadata being stored 
             2. p - path to save the files at 
    """
    with open(p + '/invoke_method.json', 'w') as im:
        json.dump(meta['invoke_method'], im, indent=4, default=set_default)
    with open(p + '/packages.json', 'w') as pack:
        json.dump(meta['packages'], pack, indent=4, default=set_default)
    with open(p + '/app_apis.json', 'w') as apis:
        json.dump(meta['app_apis'], apis, indent=4, default=set_default)
    with open(p + '/code_blocks.txt', 'w') as cb:
        for l in meta['code_blocks']:
            cb.write(str(l) + '\n')
            
def reduce_and_save_apps_apis(p,apps,apis):
    reduced_apis = {}
    for k,v in apis.items():
        if v > 5:
            reduced_apis[k] = len(reduced_apis)
            
    with open(p + '/apps.json', 'w') as a:
        json.dump(apps, a, indent=4, default=set_default)
    with open(p + '/apis.json', 'w') as api:
        json.dump(reduced_apis, api, indent=4, default=set_default)
    return reduced_apis
        
        

def read_files(p,apis):
    """
    Load metdata from files on disk 

    Params - 1. p - path to load files from 
             2. apis - data structure holding all unique APIs 
             and their primary key
    """
    #loading in all APIs for the app with counts
    with open(p + '/app_apis.json', 'r') as a:
        app_apis = json.load(a)
    #generating primary key for unique APIs
    for k in app_apis.keys():
        if k not in apis.keys():
            apis[k] = 1
        else:
            apis[k] += 1
    #getting APIs that have the same invoke type
    with open(p + '/invoke_method.json', 'r') as im:
        invoke_method = json.load(im)
    #getting APIs that are called by the same packages
    with open(p + '/packages.json', 'r') as pack:
        packages = json.load(pack)
    #gettings APIs that occur in the same method
    code_blocks = []
    with open(p + '/code_blocks.txt', 'r') as cb:
        for line in cb:
            code_blocks.append(ast.literal_eval(line))
    
    meta = {'invoke_method':invoke_method, 'packages':packages, \
            'code_blocks':code_blocks, 'app_apis': app_apis}
    return meta, apis
    

def get_category_api_calls(category, apps,apis,outpath,re_read):
    """
    Get all API calls for a given category of apps.

    Params - 1. category - the category whose API calls we want
             2. apps - dictionary of the apps with Primary Keys
             3. apis - dictionary of APIs with Primary Keys
             4. outpath - path to save the API information  
             5. re_read - if you want meta data read from disk
             6. malware_path - path of the directory containing malware apps
    """
    
    cat_info = {}

    cat_outpath = outpath+'/APK/'+category
    #case where no apps in category exist
    ## FIX - so that it runs the scraper
    if not os.path.exists(cat_outpath):
        print('Please scrape apps in ' + category + ' first.')
        return None,0

    random_num = random.choice([1,2,3,4])

    pathlist = os.listdir(cat_outpath+'/')
    
    
    #create directory for each app's metadata
    meta_data_path = outpath+'/apk_data/'
    if not os.path.exists(meta_data_path):
        os.mkdir(meta_data_path)
    cat_data_path = meta_data_path + category +'/'
    if not os.path.exists(cat_data_path):
        os.mkdir(cat_data_path)

    
    #create directory for each app's metadata
    meta_data_path = outpath+'/apk_data/'
    if not os.path.exists(meta_data_path):
        os.mkdir(meta_data_path)
    cat_data_path = meta_data_path + category +'/'
    if not os.path.exists(cat_data_path):
        os.mkdir(cat_data_path)
        
    test_info = {}
    test_apps = {}

    for i,p in enumerate(pathlist):
        #storing apps with a primary key
        if not p.startswith('.') and not p.endswith('.apk'):

            app_meta_path = cat_data_path + p
            #save meta-data files if they dont already exist
            if not os.path.exists(app_meta_path):
                os.mkdir(app_meta_path)
            #FIX so that this can be changed into an if/else part
            if re_read:
                meta = get_app_api_calls(p,outpath,False)
                save_files(meta,app_meta_path)
                
            if i+random_num % 4 != 0:
                meta,apis = read_files(app_meta_path,apis)
                cat_info[p] = meta
                if p not in apps:
                    apps[p] = len(apps)
            else:
                meta,_ = read_files(app_meta_path,{})
                test_info[p] = meta
                if p not in apps and p not in test_apps:
                    test_apps[p] = len(test_apps)
                
            #save meta data of each app for given category
            
    return cat_info, apps, apis, test_info, test_apps

def get_metadata(cats,outpath,read_files):
    """
    Method that gets .smali files for an entire category of apps
    Params - 1. cats - Categories for which we want to get API information
             2. outpath - path to save the API information
    """
    categories = {}
    test_cats = {}
    apps = defaultdict(int)
    apis = {}
    malware = []
    
    
    #looping through all categories and getting API information
    for cat in cats:
        print(cat)
        categories[cat], apps, apis,test_cats[cat], test_apps = get_category_api_calls(cat,apps,apis,outpath,read_files)
    return categories, apps,apis,test_cats, test_apps


def create_A_matrix(meta,app_id,mat,apis):
    """
    Method to create the A matrix 
    A(i,j) = if app(i) contains api(j)

    Params - 1. meta - dictionary of apps and APIs
             2. app_id - primary key of current app
             3. mat - matrix to which we will encode A(i,j)
             4. apis - dictionary of all APIs with unique keys
    """
    for api_id in meta.keys():
        if api_id in apis :
            mat[(app_id,apis[api_id])] = 1
    return mat

def create_B_matrix(meta,mat,apis):
    """
    Method to create the B matrix 
    B(i,j) = if api(i) and api(j) in the same code block

    Params - 1. meta - dictionary of apps and APIs
             2. mat - matrix to which we will encode B(i,j)
             3. apis - dictionary of all APIs with unique keys
    """
    for v in meta:
        for i,api_id1 in enumerate(v):
            for j in range(i):
                api_id2 = v[j]
                if api_id1 in apis and api_id2 in apis:
                    mat[(apis[api_id2] , apis[api_id1])] = 1
                    mat[(apis[api_id1] , apis[api_id2])] = 1
    return mat

def create_P_matrix(meta,mat,apis):
    """
    Method to create the P matrix 
    P(i,j) = if api(i) and api(j) are called using the same package

    Params - 1. meta - dictionary of apps and APIs
             2. mat - matrix to which we will encode P(i,j)
             3. apis - dictionary of all APIs with unique keys
    """
    for k,v in meta.items():
        for i,api_id1 in enumerate(v):
            for j in range(i):
                api_id2 = v[j]
                if api_id1 in apis and api_id2 in apis:
                    mat[(apis[api_id2] , apis[api_id1])] = 1
                    mat[(apis[api_id1], apis[api_id2])] = 1
    return mat

def create_matrices(category_data,app_dict,apis,outpath):   
    """
    Method to compute the A,B,P matrices
    Params - 1. category_data - metadata of all category apps
             2. app_dict - dictionary with all apps and unique keys
             3. apis - dictionary with all apis and unique keys 
    """
    #creating empty matrices
    l_api = len(apis)
    l_app = len(app_dict)
    A = lil_matrix((l_app, l_api),dtype = int) 
    B = lil_matrix((l_api, l_api),dtype = int)
    P = lil_matrix((l_api, l_api),dtype = int)
    
    #looping through each app and adding API relations for each matric
    for apps in category_data.items():
        if not apps[1]: continue
        for app,meta in apps[1].items():
            if app in app_dict:
                A = create_A_matrix(meta['app_apis'],app_dict[app],A,apis)
            B = create_B_matrix(meta['code_blocks'],B,apis)
            P = create_P_matrix(meta['packages'],P,apis)
    A = csr_matrix(A)
    B = csr_matrix(B)
    P = csr_matrix(P)
    print('done with matrices')
    matrix_path = os.path.join(outpath, 'Matrix_data')
    if not os.path.exists(matrix_path):
        os.mkdir(matrix_path)
    save_npz(matrix_path + "/a_matrix_train.npz", A)
    save_npz(matrix_path + "/b_matrix_train.npz", B)
    save_npz(matrix_path + "/p_matrix_train.npz", P)
    return A,B,P

def create_test_matrix(category_data,app_dict,apis,outpath):
    #creating empty matrices
    l_api = len(apis)
    l_app = len(app_dict)
    A = lil_matrix((l_app, l_api),dtype = int) 
    
    for apps in category_data.items():
        if not apps[1]: continue
        for app,meta in apps[1].items():
            if app in app_dict:
                A = create_A_matrix(meta['app_apis'],app_dict[app],A,apis)
    A = csr_matrix(A)
    matrix_path = os.path.join(outpath, 'Matrix_data')
    if not os.path.exists(matrix_path):
        os.mkdir(matrix_path)
    save_npz(matrix_path +"/a_matrix_test.npz", A)
    return A

def create_kernels(A,B,P):
    """
    Method to get kernels that we will be exploring with the SVM
    Params - 1. A matrix - A(i,j) = if app(i) contains api(j)
             2. B matrix - B(i,j) = if api(i) and api(j) in the same code block
             3. P matrix - P(i,j) = if api(i) and api(j) are called using the same package
    """
    kernels = {}
    kernels['a_at'] = A*A.T
    kernels['ab_at'] = A*B*A.T
    kernels['ap_at'] = A*P*A.T
    return kernels

def create_test_kernels(A,B,P,A_t):
    kernels = {}
    kernels['a_at'] = A_t*A.T
    kernels['ab_at'] = A_t*B*A.T
    kernels['ap_at'] = A_t*P*A.T
    return kernels

def load_kernels(path):
    A = load_npz(path+'/Matrix_data/a_matrix_train.npz')
    B = load_npz(path+"/Matrix_data/b_matrix_train.npz")
    P = load_npz(path+"/Matrix_data/p_matrix_train.npz")
    a_test = load_npz("data/Matrix_data/a_matrix_test.npz")
    train_kernels = create_kernels(A,B,P)
    test_kernels = create_test_kernels(A,B,P,a_test)
    return train_kernels, test_kernels
    

def get_kernels(category_data,apps,apis,test_info,test_apps):
    """
    Method to create matrices and get the kernels for SVM training

    Params - 1. category_data - metadata of all category apps
             2. apps - dictionary with all apps and unique keys
             3. apis - dictionary with all apis and unique keys 
    """
    A,B,P = create_matrices(category_data,apps,apis)
    a_test = create_test_matrix(test_info, test_apps, apis)
    train_kernels = create_kernels(A,B,P)
    test_kernels = create_test_kernels(A,B,P,a_test)
    return train_kernels, test_kernels



def get_malware(path, num_apps,category_data,apps,apis,categories,test_info,test_apps):
    
    sampled = []
    malware = defaultdict(list)
    malware_test = defaultdict(list)
    random_num = random.choice([1,2,3,4])
    for family in os.listdir(path):
        if family not in categories:
            continue
        family_data = {}
        family_data_test = {}
        base_path = os.path.join('data','apk_data',family)
        if not os.path.exists(base_path):
            os.mkdir(base_path)


        malware_apps = []
        for variety in os.listdir(os.path.join(path,family)):
            for app in os.listdir(os.path.join(path,family,variety)):
                malware_apps.append(os.path.join(path,family,variety,app))
            
        sampled_apps = sample(malware_apps, min(num_apps, len(malware_apps)))
        
        
        for i,malware_path in enumerate(sampled_apps):
            app = malware_path.split('/')[-1]
                
            app_path = os.path.join(base_path, app)
            if not os.path.exists(app_path):
                os.mkdir(app_path)
            
            meta = get_app_api_calls(app,path,True)
            save_files(meta,app_path)
            if i+random_num % 4 != 0:
                if app not in apps:
                    apps[app] = len(apps)
                    malware[family].append(apps[app])
            
                meta,apis = read_files(app_path,apis)
                family_data[app] = meta
            else:
                if app not in test_apps and app not in apps:
                    test_apps[app] = len(test_apps)
                    malware_test[family].append(test_apps[app])
                meta,_ = read_files(app_path, {})
                family_data_test[app] = meta

        category_data[family] = family_data
        test_info[family] = family_data_test
    return category_data,apps,apis, malware,test_info, test_apps, malware_test

def read_malware(cats, path,category_data,apps,apis,test_info,test_apps):
    malware = defaultdict(list)
    malware_test = defaultdict(list)
    random_num = random.choice([1,2,3,4])
    for cat in cats:
        print(cat)

            
        family_data = {}
        family_data_test = {}
        base_path = os.path.join(path, 'apk_data', cat)
        for i,app in enumerate(os.listdir(base_path)):
            
            if app.startswith("."):
                continue
            app_path = os.path.join(base_path, app)
            if i + random_num % 4 != 0:
                if app not in apps:
                    apps[app] = len(apps)
                    malware[cat].append(apps[app])
                meta,apis = read_files(app_path,apis)
                family_data[app] = meta
            else:
                if app not in test_apps and app not in apps:
                    test_apps[app] = len(test_apps)
                    malware_test[cat].append(test_apps[app])
                meta,_ = read_files(app_path, {})
                family_data_test[app] = meta
        category_data[cat] = family_data
        test_info[cat] = family_data_test
    return category_data,apps,apis, malware,test_info, test_apps, malware_test

    
    
    

